# 牛客

[Problems Index](#problems-index)

<!-- Tag: 牛客 -->

Problems Index
---
- [`牛客 No.0001 大数加法 (中等, 2022-01)`](#牛客-no0001-大数加法-中等-2022-01)
- [`牛客 No.0002 重排链表 (中等, 2022-01)`](#牛客-no0002-重排链表-中等-2022-01)
- [`牛客 No.0003 链表中环的入口结点 (简单, 2022-01)`](#牛客-no0003-链表中环的入口结点-简单-2022-01)
- [`牛客 No.0004 判断链表中是否有环 (简单, 2022-01)`](#牛客-no0004-判断链表中是否有环-简单-2022-01)
- [`牛客 No.0005 二叉树根节点到叶子节点的所有路径和 (中等, 2022-01)`](#牛客-no0005-二叉树根节点到叶子节点的所有路径和-中等-2022-01)
- [`牛客 No.0006 二叉树中的最大路径和 (困难, 2022-01)`](#牛客-no0006-二叉树中的最大路径和-困难-2022-01)
- [`牛客 No.0007 买卖股票的最好时机(一) (简单, 2022-01)`](#牛客-no0007-买卖股票的最好时机一-简单-2022-01)
- [`牛客 No.0008 二叉树中和为某一值的路径(二) (中等, 2022-01)`](#牛客-no0008-二叉树中和为某一值的路径二-中等-2022-01)
- [`牛客 No.0009 二叉树中和为某一值的路径(一) (简单, 2022-01)`](#牛客-no0009-二叉树中和为某一值的路径一-简单-2022-01)
- [`牛客 No.0010 大数乘法 (中等, 2022-01)`](#牛客-no0010-大数乘法-中等-2022-01)
- [`牛客 No.0011 将升序数组转化为平衡二叉搜索树 (简单, 2022-01)`](#牛客-no0011-将升序数组转化为平衡二叉搜索树-简单-2022-01)
- [`牛客 No.0012 重建二叉树 (中等, 2022-01)`](#牛客-no0012-重建二叉树-中等-2022-01)
- [`牛客 No.0013 二叉树的最大深度 (简单, 2022-01)`](#牛客-no0013-二叉树的最大深度-简单-2022-01)
- [`牛客 No.0014 按之字形顺序打印二叉树 (中等, 2022-01)`](#牛客-no0014-按之字形顺序打印二叉树-中等-2022-01)
- [`牛客 No.0015 求二叉树的层序遍历 (中等, 2022-01)`](#牛客-no0015-求二叉树的层序遍历-中等-2022-01)
- [`牛客 No.0016 对称的二叉树 (简单, 2022-01)`](#牛客-no0016-对称的二叉树-简单-2022-01)
- [`牛客 No.0017 最长回文子串 (中等, 2022-01)`](#牛客-no0017-最长回文子串-中等-2022-01)

---

### `牛客 No.0001 大数加法 (中等, 2022-01)`

[![字符串](https://img.shields.io/badge/字符串-lightgray.svg)](数据结构-字符串.md)
[![模拟](https://img.shields.io/badge/模拟-lightgray.svg)](基础-模拟、数学、找规律.md)
[![牛客](https://img.shields.io/badge/牛客-lightgray.svg)](题集-牛客.md)

<!--{
    "tags": ["字符串", "模拟"],
    "来源": "牛客",
    "难度": "中等",
    "编号": "0001",
    "标题": "大数加法",
    "公司": ["百度", "阿里", "字节", "虾皮"]
}-->

<summary><b>问题简述</b></summary>

```txt
以字符串的形式读入两个数字，计算它们的和，以字符串形式返回。
```
> [大数加法_牛客题霸_牛客网](https://www.nowcoder.com/practice/11ae12e8c6fe48f883cad618c2e81475)

</details>

<!-- <div align="center"><img src="../_assets/xxx.png" height="300" /></div> -->

<summary><b>思路</b></summary>

- 把较短的字符串通过补前缀 0 使长度一致，此时只要处理好进位即可；

<details><summary><b>Python</b></summary>

```python
class Solution:
    def solve(self , s: str, t: str) -> str:
        # write code here
        n, m = len(s), len(t)
        if n < m:  # 确保 n >= m
            s, t = t, s
            n, m = m, n
            
        t = '0' * (n - m) + t  # 补0
        
        ret = ''
        ex = 0  # 进位标志
        for i in range(n - 1, -1, -1):
            r = int(s[i]) + int(t[i]) + ex
            ret = str(r % 10) + ret
            ex = r // 10
            
        if ex:
            ret = '1' + ret
        
        return ret
```

</details>

---

### `牛客 No.0002 重排链表 (中等, 2022-01)`

[![链表](https://img.shields.io/badge/链表-lightgray.svg)](数据结构-链表.md)
[![牛客](https://img.shields.io/badge/牛客-lightgray.svg)](题集-牛客.md)

<!--{
    "tags": ["链表"],
    "来源": "牛客",
    "难度": "中等",
    "编号": "0002",
    "标题": "重排链表",
    "公司": ["美团", "字节", "快手"]
}-->

<summary><b>问题简述</b></summary>

```txt
给定一个单链表 L 的头节点 head ，单链表 L 表示为：
    L0 → L1 → … → Ln - 1 → Ln
请将其重新排列后变为：
    L0 → Ln → L1 → Ln-1 → L2 → Ln-2 → …
不能只是单纯的改变节点内部的值，而是需要实际的进行节点交换。
```
> [重排链表_牛客题霸_牛客网](https://www.nowcoder.com/practice/3d281dc0b3704347846a110bf561ef6b)

<!-- 
<details><summary><b>详细描述</b></summary>

```txt
```
 -->

</details>

<!-- <div align="center"><img src="../_assets/xxx.png" height="300" /></div> -->

<summary><b>思路：模拟</b></summary>

1. 先找到中间节点 mid；
2. 将链表 mid 反转；
3. 然后合并 head 和 mid；

<details><summary><b>Python</b></summary>

```python
# Definition for singly-linked list.
# class ListNode:
#     def __init__(self, val=0, next=None):
#         self.val = val
#         self.next = next
class Solution:
    def reorderList(self, head: ListNode) -> None:
        """
        Do not return anything, modify head in-place instead.
        """
        if not head: return
    
        def  get_mid(p):
            lp, fp = p, p

            while fp and fp.next:
                lp = lp.next
                fp = fp.next.next
            
            return lp
        
        def reverse(p):
            cur, pre = p, None
            while cur:
                nxt = cur.next
                cur.next = pre
                pre = cur
                cur = nxt
            
            return pre
        
        mid = get_mid(head)  # 注意此时还没有断开两个链表
        mid = reverse(mid)

        # merge
        l, r = head, mid
        while True:
            l_nxt, r_nxt = l.next, r.next
            if not r_nxt:  # 这是一种写法，另一种写法是在获得 mid 后将 mid 与原链表断开（后移一个节点，结果也是正确的，见写法2）
                break
            l.next, r.next = r, l_nxt
            l, r = l_nxt, r_nxt
```

</details>

---

### `牛客 No.0003 链表中环的入口结点 (简单, 2022-01)`

[![链表](https://img.shields.io/badge/链表-lightgray.svg)](数据结构-链表.md)
[![快慢指针](https://img.shields.io/badge/快慢指针-lightgray.svg)](技巧-双指针-快慢指针.md)
[![牛客](https://img.shields.io/badge/牛客-lightgray.svg)](题集-牛客.md)

<!--{
    "tags": ["链表", "快慢指针"],
    "来源": "牛客",
    "难度": "简单",
    "编号": "0003",
    "标题": "链表中环的入口结点",
    "公司": []
}-->

<summary><b>问题简述</b></summary>

```txt
给一个长度为 n 的链表，若其中包含环，请找出该链表的环的入口结点，否则返回null。
```
> [链表中环的入口结点_牛客题霸_牛客网](https://www.nowcoder.com/practice/253d2c59ec3e4bc68da16833f79a38e4)

<!-- 
<details><summary><b>详细描述</b></summary>

```txt
```
-->

</details>

<!-- <div align="center"><img src="../_assets/xxx.png" height="300" /></div> -->

<summary><b>思路：快慢指针</b></summary>

- 快指针 `fast` 每次走两步，慢指针 `slow` 每次走一步；
- 若存在环，则 `fast` 与 `slow` 必会相遇；
- 相遇后，将 `slow` 重新指向 `pHead`，然后，双指针正常每次走一步；
- 当再次相遇时，即为入口节点；
- 注意无环的情况；

**证明**：
- 假设存在环，记环之前的节点数即为 $a$（不包括入口节点），环的节点数为 $b$；当 `fast` 和 `slow` 相遇时距离环入口的步数为 $c$；
- 下面证明：$a=c$
- 记 `fast` 和 `slow` 走的步数分别为 $f$ 和 $s$，且 $f-s = n*b$，即 `fast` 比 `slow` 多走了 `n` 圈；又 $f=2s$，可得 $s=n*b$，而实际上 `slow` 走的距离 $s=a + (n-1)b + (b-c)$，联立得 $a=c$；
- 因此当 `fast` 和 `slow` 在环内相遇时，将 `slow` 重新指向 `pHead`，然后双指针再次相遇时即为入口节点（每次走一步）；

<details><summary><b>Python</b></summary>

```python
class Solution:
    def EntryNodeOfLoop(self, pHead: ListNode):
        # write code here

        no_cycle = True
        slow = fast = pHead
        while fast and fast.next:
            slow = slow.next
            fast = fast.next.next
            if slow == fast:
                no_cycle = False
                break

        if no_cycle:
            return None

        slow = pHead
        while slow != fast:
            slow = slow.next
            fast = fast.next

        return slow
```

</details>

---

### `牛客 No.0004 判断链表中是否有环 (简单, 2022-01)`

[![链表](https://img.shields.io/badge/链表-lightgray.svg)](数据结构-链表.md)
[![快慢指针](https://img.shields.io/badge/快慢指针-lightgray.svg)](技巧-双指针-快慢指针.md)
[![牛客](https://img.shields.io/badge/牛客-lightgray.svg)](题集-牛客.md)

<!--{
    "tags": ["链表", "快慢指针"],
    "来源": "牛客",
    "难度": "简单",
    "编号": "0004",
    "标题": "判断链表中是否有环",
    "公司": ["百度", "阿里", "小米"]
}-->

<summary><b>问题简述</b></summary>

```txt
判断给定的链表中是否有环。
```
> [判断链表中是否有环_牛客题霸_牛客网](https://www.nowcoder.com/practice/650474f313294468a4ded3ce0f7898b9)

<!-- 
<details><summary><b>详细描述</b></summary>

```txt
```
-->

</details>

<!-- <div align="center"><img src="../_assets/xxx.png" height="300" /></div> -->

<summary><b>思路：快慢指针</b></summary>

<details><summary><b>Python</b></summary>

```python
# class ListNode:
#     def __init__(self, x):
#         self.val = x
#         self.next = None

#
# @param head ListNode类 
# @return bool布尔型
#
class Solution:
    def hasCycle(self , head: ListNode) -> bool:
        
        fast = slow = head
        has_cycle = False
        while fast and fast.next:
            slow = slow.next
            fast = fast.next.next
            if slow == fast:
                has_cycle = True
                break
        
        return has_cycle
```

</details>

---

### `牛客 No.0005 二叉树根节点到叶子节点的所有路径和 (中等, 2022-01)`

[![二叉树](https://img.shields.io/badge/二叉树-lightgray.svg)](数据结构-二叉树.md)
[![DFS](https://img.shields.io/badge/DFS-lightgray.svg)](算法-深度优先搜索(DFS).md)
[![牛客](https://img.shields.io/badge/牛客-lightgray.svg)](题集-牛客.md)

<!--{
    "tags": ["二叉树", "DFS"],
    "来源": "牛客",
    "难度": "中等",
    "编号": "0005",
    "标题": "二叉树根节点到叶子节点的所有路径和",
    "公司": ["小米", "快手", "字节"]
}-->

<summary><b>问题简述</b></summary>

```txt
给定二叉树，求所有路径和，路径定义如下：
假设某条路径的从根节点到叶节点的值为 1->2->3，则记该条路径表示的值为 123；
输入确保每个节点的值在 0~9 之间；

示例
    1
   2 3
结果：25（12+13=25）
```
> [二叉树根节点到叶子节点的所有路径和_牛客题霸_牛客网](https://www.nowcoder.com/practice/185a87cd29eb42049132aed873273e83)

<!-- 
<details><summary><b>详细描述</b></summary>

```txt
```
-->

</details>

<!-- <div align="center"><img src="../_assets/xxx.png" height="300" /></div> -->

<summary><b>思路：DFS</b></summary>

<details><summary><b>Python</b></summary>

```python
# class TreeNode:
#     def __init__(self, x):
#         self.val = x
#         self.left = None
#         self.right = None
#
# 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可
#
# 
# @param root TreeNode类 
# @return int整型
#
class Solution:
    def sumNumbers(self , root: TreeNode) -> int:
        # write code here
        
        self.ret = 0
        
        def dfs(node: TreeNode, sum_):
            if not node:
                # self.ret += sum_  # 放在这里会导致“加两次”
                return
            
            sum_ = sum_ * 10 + node.val
            if not node.left and not node.right:
                self.ret += sum_
                return
            
            if node.left:
                dfs(node.left, sum_)
            if node.right:
                dfs(node.right, sum_)
        
        dfs(root, 0)
        return self.ret
```

</details>

---

### `牛客 No.0006 二叉树中的最大路径和 (困难, 2022-01)`

[![二叉树](https://img.shields.io/badge/二叉树-lightgray.svg)](数据结构-二叉树.md)
[![牛客](https://img.shields.io/badge/牛客-lightgray.svg)](题集-牛客.md)

<!--{
    "tags": ["二叉树"],
    "来源": "牛客",
    "难度": "困难",
    "编号": "0006",
    "标题": "二叉树中的最大路径和",
    "公司": ["字节", "美团", "百度"]
}-->

<summary><b>问题简述</b></summary>

```txt
求给定二叉树中的最大路径和。
路径定义：
    1. 同一个节点在路径中最多出现一次；
    2. 路径至少包含一个节点，可以不经过根节点；
```
> [二叉树中的最大路径和_牛客题霸_牛客网](https://www.nowcoder.com/practice/da785ea0f64b442488c125b441a4ba4a)

<!-- 
<details><summary><b>详细描述</b></summary>

```txt
```
-->

</details>

<!-- <div align="center"><img src="../_assets/xxx.png" height="300" /></div> -->

<summary><b>思路：DFS</b></summary>

- 定义函数 `maxGain(node)` 表示以 `node` 为**起点**的最大路径；显然 maxGain 可以通过递归计算（详见代码）；
- 则**经过** `node` 的最大路径和，可以表示为 `node.val + maxGain(node.left), maxGain(node.right)`；因此可以在计算 `maxGain(root)` 的过程中，记录经过每个节点的最大路径和，进而得到全局最大路径。

<details><summary><b>Python</b></summary>

```python
# class TreeNode:
#     def __init__(self, x):
#         self.val = x
#         self.left = None
#         self.right = None
#
# 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可
#
# 
# @param root TreeNode类 
# @return int整型
#
class Solution:
    def maxPathSum(self, root: TreeNode) -> int:
        # write code here

        self.ret = float('-inf')

        def maxGain(node):
            if not node: return 0

            # 如果子路径的 maxGain 为负数，那么对 node 来说 maxGain 就是自己本身；
            max_left = max(0, maxGain(node.left))
            max_right = max(0, maxGain(node.right))
            # 记录“经过”node 节点的最大路径
            self.ret = max(self.ret, node.val + max_left + max_right)
            return node.val + max(max_left, max_right)  # 至少要包含自己本身

        maxGain(root)
        return self.ret
```

</details>

---

### `牛客 No.0007 买卖股票的最好时机(一) (简单, 2022-01)`

[![模拟](https://img.shields.io/badge/模拟-lightgray.svg)](基础-模拟、数学、找规律.md)
[![牛客](https://img.shields.io/badge/牛客-lightgray.svg)](题集-牛客.md)

<!--{
    "tags": ["模拟"],
    "来源": "牛客",
    "难度": "简单",
    "编号": "0007",
    "标题": "买卖股票的最好时机(一)",
    "公司": ["字节", "腾讯"]
}-->

<summary><b>问题简述</b></summary>

```txt
给定一支股票的价格序列，返回买卖一次的最大值；
```
> [买卖股票的最好时机(一)_牛客题霸_牛客网](https://www.nowcoder.com/practice/64b4262d4e6d4f6181cd45446a5821ec)

<!-- 
<details><summary><b>详细描述</b></summary>

```txt
```
-->

</details>

<!-- <div align="center"><img src="../_assets/xxx.png" height="300" /></div> -->

<summary><b>思路：动态规划</b></summary>

- 记 `dp[i]` 表示 `prices[:i]` 中的最小值；
- 则 `ret = max(x - dp[i])`；
- 实际可以用一个变量记录当前最小值，节省空间；

<details><summary><b>Python</b></summary>

```python
#
# 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可
#
# 
# @param prices int整型一维数组 
# @return int整型
#
class Solution:
    def maxProfit(self , prices: List[int]) -> int:
        # write code here
        ret = 0
        min_p = prices[0]
        for x in prices[1:]:
            ret = max(ret, x - min_p)
            min_p = min(x, min_p)
        return ret
```

</details>

---

### `牛客 No.0008 二叉树中和为某一值的路径(二) (中等, 2022-01)`

[![二叉树](https://img.shields.io/badge/二叉树-lightgray.svg)](数据结构-二叉树.md)
[![DFS](https://img.shields.io/badge/DFS-lightgray.svg)](算法-深度优先搜索(DFS).md)
[![牛客](https://img.shields.io/badge/牛客-lightgray.svg)](题集-牛客.md)

<!--{
    "tags": ["二叉树", "DFS"],
    "来源": "牛客",
    "难度": "中等",
    "编号": "0008",
    "标题": "二叉树中和为某一值的路径(二)",
    "公司": []
}-->

<summary><b>问题简述</b></summary>

```txt
给定二叉树 root 和目标值 target，返回所有和为 target 的路径。
规定路径必须从根节点开始到叶子节点。
```
> [二叉树中和为某一值的路径(二)_牛客题霸_牛客网](https://www.nowcoder.com/practice/b736e784e3e34731af99065031301bca)

<!-- 
<details><summary><b>详细描述</b></summary>

```txt
```
-->

</details>

<!-- <div align="center"><img src="../_assets/xxx.png" height="300" /></div> -->

<summary><b>思路：DFS</b></summary>

<details><summary><b>Python</b></summary>

```python
# class TreeNode:
#     def __init__(self, x):
#         self.val = x
#         self.left = None
#         self.right = None
#
# 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可
#
# 
# @param root TreeNode类 
# @param target int整型 
# @return int整型二维数组
#
class Solution:
    def FindPath(self , root: TreeNode, target: int) -> List[List[int]]:
        # write code here
        
        ret = []
        tmp = []
        
        def dfs(node, k):
            if not node: return
            
            tmp.append(node.val)
            k -= node.val
            
            if not node.left and not node.right and k == 0:
                ret.append(tmp[:])
            
            dfs(node.left, k)
            dfs(node.right, k)
            k += node.val
            tmp.pop()
        
        dfs(root, target)
        return ret
```

</details>

---

### `牛客 No.0009 二叉树中和为某一值的路径(一) (简单, 2022-01)`

[![二叉树](https://img.shields.io/badge/二叉树-lightgray.svg)](数据结构-二叉树.md)
[![DFS](https://img.shields.io/badge/DFS-lightgray.svg)](算法-深度优先搜索(DFS).md)
[![牛客](https://img.shields.io/badge/牛客-lightgray.svg)](题集-牛客.md)

<!--{
    "tags": ["二叉树", "DFS"],
    "来源": "牛客",
    "难度": "简单",
    "编号": "0009",
    "标题": "二叉树中和为某一值的路径(一)",
    "公司": ["腾讯", "字节", "京东"]
}-->

<summary><b>问题简述</b></summary>

```txt
给定二叉树 root 和目标值 target，判断是否存在路径和等于 target。
规定路径必须从根节点开始到叶子节点。
```
> [二叉树中和为某一值的路径(一)_牛客题霸_牛客网](https://www.nowcoder.com/practice/508378c0823c423baa723ce448cbfd0c)

<!-- 
<details><summary><b>详细描述</b></summary>

```txt
```
-->

</details>

<!-- <div align="center"><img src="../_assets/xxx.png" height="300" /></div> -->

<summary><b>思路：DFS</b></summary>

<details><summary><b>Python</b></summary>

```python
# class TreeNode:
#     def __init__(self, x):
#         self.val = x
#         self.left = None
#         self.right = None
#
# 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可
#
# 
# @param root TreeNode类 
# @param sum int整型 
# @return bool布尔型
#
class Solution:
    def hasPathSum(self , root: TreeNode, sum: int) -> bool:
        # write code here
        
        def dfs(node, k):
            if not node: return False
            
            if k == node.val and not node.left and not node.right:
                return True
            
            return dfs(node.left, k - node.val) or dfs(node.right, k - node.val)
        
        return dfs(root, sum)
```

</details>

---

### `牛客 No.0010 大数乘法 (中等, 2022-01)`

[![字符串](https://img.shields.io/badge/字符串-lightgray.svg)](数据结构-字符串.md)
[![模拟](https://img.shields.io/badge/模拟-lightgray.svg)](基础-模拟、数学、找规律.md)
[![牛客](https://img.shields.io/badge/牛客-lightgray.svg)](题集-牛客.md)

<!--{
    "tags": ["字符串", "模拟"],
    "来源": "牛客",
    "难度": "中等",
    "编号": "0010",
    "标题": "大数乘法",
    "公司": ["腾讯", "阿里", "字节"]
}-->

<summary><b>问题简述</b></summary>

```txt
以字符串的形式读入两个数字，编写一个函数计算它们的乘积，以字符串形式返回。
```
> http://

<!-- 
<details><summary><b>详细描述</b></summary>

```txt
```
-->

</details>

<!-- <div align="center"><img src="../_assets/xxx.png" height="300" /></div> -->

<summary><b>思路1：模拟</b></summary>

```
以 54 * 68 为例：

    54
  x 68
  -----

用 tmp 记录每一步的结果

8 * 4 = 32      tmp = [32]
8 * 5 = 40      tmp = [40, 32]
6 * 4 = 24      tmp = [40 + 24, 32]
6 * 5 = 30      tmp = [30, 40 + 24, 32]

得到 tmp 后做循环进位加法即可，详见代码；
```

- 示例中按照手算习惯是从低位开始算起的，实际因为各位之间互相独立，从高位开始也可以，详见代码；

<details><summary><b>Python</b></summary>

```python
#
# 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可
#
# 
# @param s string字符串 第一个整数
# @param t string字符串 第二个整数
# @return string字符串
#
class Solution:
    def solve(self , s: str, t: str) -> str:
        from collections import deque
        
        # write code here
        tmp = []
        # 从高位开始算起
        for i, a in enumerate(s):
            for j, b in enumerate(t):
                c = int(a) * int(b)
                if i + j == len(tmp):
                    tmp.append(c)
                else:
                    tmp[i + j] += c
        
        ret = deque()
        add = 0  # 进位
        for x in tmp[::-1]:  # 因为要考虑进位，所以从低位开始算起，即逆序遍历
            x += add
            add = x // 10
            ret.appendleft(str(x % 10))  # 这里也可以直接拼字符串，不过推荐用队列
        
        if add:
            ret.appendleft(str(add))
            
        return ''.join(ret)
```

</details>

---

### `牛客 No.0011 将升序数组转化为平衡二叉搜索树 (简单, 2022-01)`

[![二叉树](https://img.shields.io/badge/二叉树-lightgray.svg)](数据结构-二叉树.md)
[![牛客](https://img.shields.io/badge/牛客-lightgray.svg)](题集-牛客.md)

<!--{
    "tags": ["二叉树"],
    "来源": "牛客",
    "难度": "简单",
    "编号": "0011",
    "标题": "将升序数组转化为平衡二叉搜索树",
    "公司": ["百度", "映客"]
}-->

<summary><b>问题简述</b></summary>

```txt
给定升序数组，转化为平衡二叉搜索树（BST）
```
> [将升序数组转化为平衡二叉搜索树_牛客题霸_牛客网](https://www.nowcoder.com/practice/7e5b00f94b254da599a9472fe5ab283d)

<!-- 
<details><summary><b>详细描述</b></summary>

```txt
```
-->

</details>

<!-- <div align="center"><img src="../_assets/xxx.png" height="300" /></div> -->

<summary><b>思路</b></summary>

- 每次选择中间节点作为根节点，按先序遍历递归构建 BST；

<details><summary><b>Python</b></summary>

```python
# class TreeNode:
#     def __init__(self, x):
#         self.val = x
#         self.left = None
#         self.right = None
#
# 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可
#
# 
# @param num int整型一维数组 
# @return TreeNode类
#
class Solution:
    def sortedArrayToBST(self , num: List[int]) -> TreeNode:
        # write code here
        def dfs(arr):
            if not arr: return None
            
            l, r = 0, len(arr) - 1
            mid = (l + r) // 2
            
            node = TreeNode(arr[mid])
            node.left = dfs(arr[:mid])
            node.right = dfs(arr[mid + 1:])
            
            return node
        
        return dfs(num)
```

</details>

---

### `牛客 No.0012 重建二叉树 (中等, 2022-01)`

[![二叉树](https://img.shields.io/badge/二叉树-lightgray.svg)](数据结构-二叉树.md)
[![牛客](https://img.shields.io/badge/牛客-lightgray.svg)](题集-牛客.md)

<!--{
    "tags": ["二叉树"],
    "来源": "牛客",
    "难度": "中等",
    "编号": "0012",
    "标题": "重建二叉树",
    "公司": ["小米", "携程", "腾讯", "字节"]
}-->

<summary><b>问题简述</b></summary>

```txt
给定二叉树的前序和中序遍历结果，重建二叉树；
规定二叉树中各节点的值都不相同；
```
> [重建二叉树_牛客题霸_牛客网](https://www.nowcoder.com/practice/8a19cbe657394eeaac2f6ea9b0f6fcf6)

<!-- 
<details><summary><b>详细描述</b></summary>

```txt
```
-->

</details>

<!-- <div align="center"><img src="../_assets/xxx.png" height="300" /></div> -->

<summary><b>思路</b></summary>

- 前序遍历的第一个节点为根节点，在中序遍历中找到根节点的位置，其左边部分为左子树，右边为右子树，然后按前序遍历递归构建整个树；

<details><summary><b>Python</b></summary>

```python
# class TreeNode:
#     def __init__(self, x):
#         self.val = x
#         self.left = None
#         self.right = None
#
# 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可
#
# 
# @param pre int整型一维数组 
# @param vin int整型一维数组 
# @return TreeNode类
#
class Solution:
    def reConstructBinaryTree(self , pre: List[int], vin: List[int]) -> TreeNode:
        # write code here
        
        def dfs(p, i):
            if not p or not i: return None
            
            val = p[0]
            idx = i.index(val)
            node = TreeNode(val)
            
            node.left = dfs(p[1:idx + 1], i[:idx])
            node.right = dfs(p[idx + 1:], i[idx + 1:])
            
            return node
        
        return dfs(pre, vin)
```

</details>

---

### `牛客 No.0013 二叉树的最大深度 (简单, 2022-01)`

[![二叉树](https://img.shields.io/badge/二叉树-lightgray.svg)](数据结构-二叉树.md)
[![牛客](https://img.shields.io/badge/牛客-lightgray.svg)](题集-牛客.md)

<!--{
    "tags": ["二叉树"],
    "来源": "牛客",
    "难度": "简单",
    "编号": "0013",
    "标题": "二叉树的最大深度",
    "公司": ["字节", "小米", "阿里"]
}-->

<summary><b>问题简述</b></summary>

```txt
求给定二叉树的最大深度。
```
> http://

<!-- 
<details><summary><b>详细描述</b></summary>

```txt
```
-->

</details>

<!-- <div align="center"><img src="../_assets/xxx.png" height="300" /></div> -->

<summary><b>思路</b></summary>

<details><summary><b>Python</b></summary>

```python
# class TreeNode:
#     def __init__(self, x):
#         self.val = x
#         self.left = None
#         self.right = None
#
# 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可
#
# 
# @param root TreeNode类 
# @return int整型
#
class Solution:
    def maxDepth(self , root: TreeNode) -> int:
        # write code here
        
        def dfs(node):
            if not node: return 0
            
            return 1 + max(dfs(node.left), dfs(node.right))
        
        return dfs(root)
```

</details>

---

### `牛客 No.0014 按之字形顺序打印二叉树 (中等, 2022-01)`

[![二叉树](https://img.shields.io/badge/二叉树-lightgray.svg)](数据结构-二叉树.md)
[![队列](https://img.shields.io/badge/队列-lightgray.svg)](数据结构-栈、队列.md)
[![牛客](https://img.shields.io/badge/牛客-lightgray.svg)](题集-牛客.md)

<!--{
    "tags": ["二叉树", "队列"],
    "来源": "牛客",
    "难度": "中等",
    "编号": "0014",
    "标题": "按之字形顺序打印二叉树",
    "公司": []
}-->

<summary><b>问题简述</b></summary>

```txt
层序遍历二叉树，按之字形打印每层。
```
> [按之字形顺序打印二叉树_牛客题霸_牛客网](https://www.nowcoder.com/practice/91b69814117f4e8097390d107d2efbe0)

<!-- 
<details><summary><b>详细描述</b></summary>

```txt
```
-->

</details>

<!-- <div align="center"><img src="../_assets/xxx.png" height="300" /></div> -->

<summary><b>思路</b></summary>

- 队列 + 奇偶讨论，思路比较简单，因为需要把层分离，所以需要借助的辅助变量比较多，详见代码；

<details><summary><b>Python</b></summary>

```python
# class TreeNode:
#     def __init__(self, x):
#         self.val = x
#         self.left = None
#         self.right = None
#
# 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可
#
# 
# @param pRoot TreeNode类 
# @return int整型二维数组
#
class Solution:
    def Print(self , pRoot: TreeNode) -> List[List[int]]:
        # write code here
        if not pRoot: return []
        
        from collections import deque
        
        ret = []
        q = deque()
        q.append(pRoot)
        cnt = 1
        nxt = 0  # 下一层需要遍历的节点数
        lv = 0  # 已经遍历的层数
        tmp = []  # 当前层缓存的节点数
        while cnt:
            cnt -= 1
            node = q.popleft()
            tmp.append(node.val)
            
            if node.left:
                q.append(node.left)
                nxt += 1
            if node.right:
                q.append(node.right)
                nxt += 1
            
            if cnt == 0:
                if lv % 2:
                    ret.append(tmp[::-1])
                else:
                    ret.append(tmp)
                tmp = []
                lv += 1
                cnt = nxt
                nxt = 0
                
        return ret
```

</details>

---

### `牛客 No.0015 求二叉树的层序遍历 (中等, 2022-01)`

[![二叉树](https://img.shields.io/badge/二叉树-lightgray.svg)](数据结构-二叉树.md)
[![牛客](https://img.shields.io/badge/牛客-lightgray.svg)](题集-牛客.md)

<!--{
    "tags": ["二叉树"],
    "来源": "牛客",
    "难度": "中等",
    "编号": "0015",
    "标题": "求二叉树的层序遍历",
    "公司": ["腾讯", "美团", "小米", "神策数据"]
}-->

<summary><b>问题简述</b></summary>

```txt
层序遍历二叉树，每层的结果单独保存在一个列表中。
```
> [求二叉树的层序遍历_牛客题霸_牛客网](https://www.nowcoder.com/practice/04a5560e43e24e9db4595865dc9c63a3)

<!-- 
<details><summary><b>详细描述</b></summary>

```txt
```
-->

</details>

<!-- <div align="center"><img src="../_assets/xxx.png" height="300" /></div> -->

<summary><b>思路</b></summary>

- 辅助队列

<details><summary><b>Python</b></summary>

```python
# class TreeNode:
#     def __init__(self, x):
#         self.val = x
#         self.left = None
#         self.right = None
#
# 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可
#
# 
# @param root TreeNode类 
# @return int整型二维数组
#
class Solution:
    def levelOrder(self , root: TreeNode) -> List[List[int]]:
        # write code here
        if not root: return []
        
        from collections import deque
        
        ret = []
        q = deque()
        q.append(root)
        cnt = 1
        nxt = 0
        tmp = []
        while cnt:
            cnt -= 1
            node = q.popleft()
            tmp.append(node.val)
            
            if node.left:
                q.append(node.left)
                nxt += 1
            if node.right:
                q.append(node.right)
                nxt += 1
                
            if cnt == 0:
                ret.append(tmp)
                tmp = []
                cnt = nxt
                nxt = 0
        
        return ret
```

</details>

---

### `牛客 No.0016 对称的二叉树 (简单, 2022-01)`

[![二叉树](https://img.shields.io/badge/二叉树-lightgray.svg)](数据结构-二叉树.md)
[![牛客](https://img.shields.io/badge/牛客-lightgray.svg)](题集-牛客.md)

<!--{
    "tags": ["二叉树"],
    "来源": "牛客",
    "难度": "简单",
    "编号": "0016",
    "标题": "对称的二叉树",
    "公司": []
}-->

<summary><b>问题简述</b></summary>

```txt
判断给定二叉树是否对称。
```
> [对称的二叉树_牛客题霸_牛客网](https://www.nowcoder.com/practice/ff05d44dfdb04e1d83bdbdab320efbcb)

<!-- 
<details><summary><b>详细描述</b></summary>

```txt
```
-->

</details>

<!-- <div align="center"><img src="../_assets/xxx.png" height="300" /></div> -->

<summary><b>思路</b></summary>

- 跟一般的二叉树递归略有不同，因为对称的二叉树，其子树并不对称；

<details><summary><b>Python</b></summary>

```python
# class TreeNode:
#     def __init__(self, x):
#         self.val = x
#         self.left = None
#         self.right = None
#
# 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可
#
# 
# @param pRoot TreeNode类 
# @return bool布尔型
#
class Solution:
    def isSymmetrical(self , pRoot: TreeNode) -> bool:
        # write code here
        if not pRoot: return True
        
        def dfs(l, r):
            if not l and not r: return True  # 同时到达叶节点
            if not l or not r: return False
            
            return l.val == r.val and dfs(l.left, r.right) and dfs(l.right, r.left)
            
        return dfs(pRoot.left, pRoot.right)
```

</details>

---

### `牛客 No.0017 最长回文子串 (中等, 2022-01)`

[![模拟](https://img.shields.io/badge/模拟-lightgray.svg)](基础-模拟、数学、找规律.md)
[![DP](https://img.shields.io/badge/DP-lightgray.svg)](算法-动态规划(记忆化搜索)、递推.md)
[![牛客](https://img.shields.io/badge/牛客-lightgray.svg)](题集-牛客.md)

<!--{
    "tags": ["模拟", "DP"],
    "来源": "牛客",
    "难度": "中等",
    "编号": "0017",
    "标题": "最长回文子串",
    "公司": ["腾讯", "华为", "美团", "京东"]
}-->

<summary><b>问题简述</b></summary>

```txt
求给定字符串中最长回文子串的长度。
```
> [最长回文子串_牛客题霸_牛客网](https://www.nowcoder.com/practice/b4525d1d84934cf280439aeecc36f4af)

<!-- 
<details><summary><b>详细描述</b></summary>

```txt
```
-->

</details>

<!-- <div align="center"><img src="../_assets/xxx.png" height="300" /></div> -->

<summary><b>思路1：模拟中心扩散（推荐）</b></summary>

- 中心扩散直观，且不需要额外的空间，比动态规划的方法更好；

<details><summary><b>Python</b></summary>

```python
#
# 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可
#
# 
# @param A string字符串 
# @return int整型
#
class Solution:
    def getLongestPalindrome(self , A: str) -> int:
        # write code here
        n = len(A)
        
        def process(l, r):
            tmp = 1  # 使用一个变量保存已知的最大长度
            while l >= 0 and r < n:
                if A[l] != A[r]:
                    break
                tmp = r - l + 1
                l -= 1
                r += 1
            # return r - l + 1  # 直接返回有问题，无法判断最后一次是否匹配上
            return tmp
        
        ret = 1
        for i in range(len(A) - 1):
            # 同时处理 process(i, i), process(i, i + 1) 避免奇偶的讨论
            ret = max(ret, process(i, i), process(i, i + 1))
            
        return ret
```

</details>


<summary><b>思路2：动态规划</b></summary>

- DP 虽然能解，但是不够直观，且初始状态容易写错（相邻两个字符相同的情况）；

<details><summary><b>Python</b></summary>

```python
#
# 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可
#
# 
# @param A string字符串 
# @return int整型
#
class Solution:
    def getLongestPalindrome(self , A: str) -> int:
        # write code here
        n = len(A)
        dp = [[0] * n for _ in range(n)]

        for i in range(n):
            dp[i][i] = 1
        
        start = 0
        length = 1
        for j in range(1, n):  # 子串的结束位置
            for i in range(j - 1, -1, -1):  # 子串的开始位置
                if i == j - 1:
                    dp[i][j] = 1 if A[i] == A[j] else 0
                else:
                    dp[i][j] = 1 if dp[i + 1][j - 1] and A[i] == A[j] else 0

                if dp[i][j]:
                    if j - i + 1 > length:
                        length = j - i + 1
                        start = i

        return length
```

</details>

---
