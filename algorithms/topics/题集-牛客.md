# 牛客

[Problems Index](#problems-index)

<!-- Tag: 牛客 -->

Problems Index
---
- [`牛客 No.0001 大数加法 (中等, 2022-01)`](#牛客-no0001-大数加法-中等-2022-01)
- [`牛客 No.0002 重排链表 (中等, 2022-01)`](#牛客-no0002-重排链表-中等-2022-01)
- [`牛客 No.0003 链表中环的入口结点 (简单, 2022-01)`](#牛客-no0003-链表中环的入口结点-简单-2022-01)
- [`牛客 No.0004 判断链表中是否有环 (简单, 2022-01)`](#牛客-no0004-判断链表中是否有环-简单-2022-01)
- [`牛客 No.0005 二叉树根节点到叶子节点的所有路径和 (中等, 2022-01)`](#牛客-no0005-二叉树根节点到叶子节点的所有路径和-中等-2022-01)
- [`牛客 No.0006 二叉树中的最大路径和 (困难, 2022-01)`](#牛客-no0006-二叉树中的最大路径和-困难-2022-01)
- [`牛客 No.0007 买卖股票的最好时机(一) (简单, 2022-01)`](#牛客-no0007-买卖股票的最好时机一-简单-2022-01)
- [`牛客 No.0008 二叉树中和为某一值的路径(二) (中等, 2022-01)`](#牛客-no0008-二叉树中和为某一值的路径二-中等-2022-01)
- [`牛客 No.0009 二叉树中和为某一值的路径(一) (简单, 2022-01)`](#牛客-no0009-二叉树中和为某一值的路径一-简单-2022-01)

---

### `牛客 No.0001 大数加法 (中等, 2022-01)`

[![字符串](https://img.shields.io/badge/字符串-lightgray.svg)](数据结构-字符串.md)
[![模拟](https://img.shields.io/badge/模拟-lightgray.svg)](基础-模拟、数学、找规律.md)
[![牛客](https://img.shields.io/badge/牛客-lightgray.svg)](题集-牛客.md)

<!--{
    "tags": ["字符串", "模拟"],
    "来源": "牛客",
    "难度": "中等",
    "编号": "0001",
    "标题": "大数加法",
    "公司": ["百度", "阿里", "字节", "虾皮"]
}-->

<summary><b>问题简述</b></summary>

```txt
以字符串的形式读入两个数字，计算它们的和，以字符串形式返回。
```
> [大数加法_牛客题霸_牛客网](https://www.nowcoder.com/practice/11ae12e8c6fe48f883cad618c2e81475)

</details>

<!-- <div align="center"><img src="../_assets/xxx.png" height="300" /></div> -->

<summary><b>思路</b></summary>

- 把较短的字符串通过补前缀 0 使长度一致，此时只要处理好进位即可；

<details><summary><b>Python</b></summary>

```python
class Solution:
    def solve(self , s: str, t: str) -> str:
        # write code here
        n, m = len(s), len(t)
        if n < m:  # 确保 n >= m
            s, t = t, s
            n, m = m, n
            
        t = '0' * (n - m) + t  # 补0
        
        ret = ''
        ex = 0  # 进位标志
        for i in range(n - 1, -1, -1):
            r = int(s[i]) + int(t[i]) + ex
            ret = str(r % 10) + ret
            ex = r // 10
            
        if ex:
            ret = '1' + ret
        
        return ret
```

</details>

---

### `牛客 No.0002 重排链表 (中等, 2022-01)`

[![链表](https://img.shields.io/badge/链表-lightgray.svg)](数据结构-链表.md)
[![牛客](https://img.shields.io/badge/牛客-lightgray.svg)](题集-牛客.md)

<!--{
    "tags": ["链表"],
    "来源": "牛客",
    "难度": "中等",
    "编号": "0002",
    "标题": "重排链表",
    "公司": ["美团", "字节", "快手"]
}-->

<summary><b>问题简述</b></summary>

```txt
给定一个单链表 L 的头节点 head ，单链表 L 表示为：
    L0 → L1 → … → Ln - 1 → Ln
请将其重新排列后变为：
    L0 → Ln → L1 → Ln-1 → L2 → Ln-2 → …
不能只是单纯的改变节点内部的值，而是需要实际的进行节点交换。
```
> [重排链表_牛客题霸_牛客网](https://www.nowcoder.com/practice/3d281dc0b3704347846a110bf561ef6b)

<!-- 
<details><summary><b>详细描述</b></summary>

```txt
```
 -->

</details>

<!-- <div align="center"><img src="../_assets/xxx.png" height="300" /></div> -->

<summary><b>思路：模拟</b></summary>

1. 先找到中间节点 mid；
2. 将链表 mid 反转；
3. 然后合并 head 和 mid；

<details><summary><b>Python</b></summary>

```python
# Definition for singly-linked list.
# class ListNode:
#     def __init__(self, val=0, next=None):
#         self.val = val
#         self.next = next
class Solution:
    def reorderList(self, head: ListNode) -> None:
        """
        Do not return anything, modify head in-place instead.
        """
        if not head: return
    
        def  get_mid(p):
            lp, fp = p, p

            while fp and fp.next:
                lp = lp.next
                fp = fp.next.next
            
            return lp
        
        def reverse(p):
            cur, pre = p, None
            while cur:
                nxt = cur.next
                cur.next = pre
                pre = cur
                cur = nxt
            
            return pre
        
        mid = get_mid(head)  # 注意此时还没有断开两个链表
        mid = reverse(mid)

        # merge
        l, r = head, mid
        while True:
            l_nxt, r_nxt = l.next, r.next
            if not r_nxt:  # 这是一种写法，另一种写法是在获得 mid 后将 mid 与原链表断开（后移一个节点，结果也是正确的，见写法2）
                break
            l.next, r.next = r, l_nxt
            l, r = l_nxt, r_nxt
```

</details>

---

### `牛客 No.0003 链表中环的入口结点 (简单, 2022-01)`

[![链表](https://img.shields.io/badge/链表-lightgray.svg)](数据结构-链表.md)
[![快慢指针](https://img.shields.io/badge/快慢指针-lightgray.svg)](技巧-双指针-快慢指针.md)
[![牛客](https://img.shields.io/badge/牛客-lightgray.svg)](题集-牛客.md)

<!--{
    "tags": ["链表", "快慢指针"],
    "来源": "牛客",
    "难度": "简单",
    "编号": "0003",
    "标题": "链表中环的入口结点",
    "公司": []
}-->

<summary><b>问题简述</b></summary>

```txt
给一个长度为 n 的链表，若其中包含环，请找出该链表的环的入口结点，否则返回null。
```
> [链表中环的入口结点_牛客题霸_牛客网](https://www.nowcoder.com/practice/253d2c59ec3e4bc68da16833f79a38e4)

<!-- 
<details><summary><b>详细描述</b></summary>

```txt
```
-->

</details>

<!-- <div align="center"><img src="../_assets/xxx.png" height="300" /></div> -->

<summary><b>思路：快慢指针</b></summary>

- 快指针 `fast` 每次走两步，慢指针 `slow` 每次走一步；
- 若存在环，则 `fast` 与 `slow` 必会相遇；
- 相遇后，将 `slow` 重新指向 `pHead`，然后，双指针正常每次走一步；
- 当再次相遇时，即为入口节点；
- 注意无环的情况；

**证明**：
- 假设存在环，记环之前的节点数即为 $a$（不包括入口节点），环的节点数为 $b$；当 `fast` 和 `slow` 相遇时距离环入口的步数为 $c$；
- 下面证明：$a=c$
- 记 `fast` 和 `slow` 走的步数分别为 $f$ 和 $s$，且 $f-s = n*b$，即 `fast` 比 `slow` 多走了 `n` 圈；又 $f=2s$，可得 $s=n*b$，而实际上 `slow` 走的距离 $s=a + (n-1)b + (b-c)$，联立得 $a=c$；
- 因此当 `fast` 和 `slow` 在环内相遇时，将 `slow` 重新指向 `pHead`，然后双指针再次相遇时即为入口节点（每次走一步）；

<details><summary><b>Python</b></summary>

```python
class Solution:
    def EntryNodeOfLoop(self, pHead: ListNode):
        # write code here

        no_cycle = True
        slow = fast = pHead
        while fast and fast.next:
            slow = slow.next
            fast = fast.next.next
            if slow == fast:
                no_cycle = False
                break

        if no_cycle:
            return None

        slow = pHead
        while slow != fast:
            slow = slow.next
            fast = fast.next

        return slow
```

</details>

---

### `牛客 No.0004 判断链表中是否有环 (简单, 2022-01)`

[![链表](https://img.shields.io/badge/链表-lightgray.svg)](数据结构-链表.md)
[![快慢指针](https://img.shields.io/badge/快慢指针-lightgray.svg)](技巧-双指针-快慢指针.md)
[![牛客](https://img.shields.io/badge/牛客-lightgray.svg)](题集-牛客.md)

<!--{
    "tags": ["链表", "快慢指针"],
    "来源": "牛客",
    "难度": "简单",
    "编号": "0004",
    "标题": "判断链表中是否有环",
    "公司": ["百度", "阿里", "小米"]
}-->

<summary><b>问题简述</b></summary>

```txt
判断给定的链表中是否有环。
```
> [判断链表中是否有环_牛客题霸_牛客网](https://www.nowcoder.com/practice/650474f313294468a4ded3ce0f7898b9)

<!-- 
<details><summary><b>详细描述</b></summary>

```txt
```
-->

</details>

<!-- <div align="center"><img src="../_assets/xxx.png" height="300" /></div> -->

<summary><b>思路：快慢指针</b></summary>

<details><summary><b>Python</b></summary>

```python
# class ListNode:
#     def __init__(self, x):
#         self.val = x
#         self.next = None

#
# @param head ListNode类 
# @return bool布尔型
#
class Solution:
    def hasCycle(self , head: ListNode) -> bool:
        
        fast = slow = head
        has_cycle = False
        while fast and fast.next:
            slow = slow.next
            fast = fast.next.next
            if slow == fast:
                has_cycle = True
                break
        
        return has_cycle
```

</details>

---

### `牛客 No.0005 二叉树根节点到叶子节点的所有路径和 (中等, 2022-01)`

[![二叉树](https://img.shields.io/badge/二叉树-lightgray.svg)](数据结构-二叉树.md)
[![DFS](https://img.shields.io/badge/DFS-lightgray.svg)](算法-深度优先搜索(DFS).md)
[![牛客](https://img.shields.io/badge/牛客-lightgray.svg)](题集-牛客.md)

<!--{
    "tags": ["二叉树", "DFS"],
    "来源": "牛客",
    "难度": "中等",
    "编号": "0005",
    "标题": "二叉树根节点到叶子节点的所有路径和",
    "公司": ["小米", "快手", "字节"]
}-->

<summary><b>问题简述</b></summary>

```txt
给定二叉树，求所有路径和，路径定义如下：
假设某条路径的从根节点到叶节点的值为 1->2->3，则记该条路径表示的值为 123；
输入确保每个节点的值在 0~9 之间；

示例
    1
   2 3
结果：25（12+13=25）
```
> [二叉树根节点到叶子节点的所有路径和_牛客题霸_牛客网](https://www.nowcoder.com/practice/185a87cd29eb42049132aed873273e83)

<!-- 
<details><summary><b>详细描述</b></summary>

```txt
```
-->

</details>

<!-- <div align="center"><img src="../_assets/xxx.png" height="300" /></div> -->

<summary><b>思路：DFS</b></summary>

<details><summary><b>Python</b></summary>

```python
# class TreeNode:
#     def __init__(self, x):
#         self.val = x
#         self.left = None
#         self.right = None
#
# 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可
#
# 
# @param root TreeNode类 
# @return int整型
#
class Solution:
    def sumNumbers(self , root: TreeNode) -> int:
        # write code here
        
        self.ret = 0
        
        def dfs(node: TreeNode, sum_):
            if not node:
                # self.ret += sum_  # 放在这里会导致“加两次”
                return
            
            sum_ = sum_ * 10 + node.val
            if not node.left and not node.right:
                self.ret += sum_
                return
            
            if node.left:
                dfs(node.left, sum_)
            if node.right:
                dfs(node.right, sum_)
        
        dfs(root, 0)
        return self.ret
```

</details>

---

### `牛客 No.0006 二叉树中的最大路径和 (困难, 2022-01)`

[![二叉树](https://img.shields.io/badge/二叉树-lightgray.svg)](数据结构-二叉树.md)
[![牛客](https://img.shields.io/badge/牛客-lightgray.svg)](题集-牛客.md)

<!--{
    "tags": ["二叉树"],
    "来源": "牛客",
    "难度": "困难",
    "编号": "0006",
    "标题": "二叉树中的最大路径和",
    "公司": ["字节", "美团", "百度"]
}-->

<summary><b>问题简述</b></summary>

```txt
求给定二叉树中的最大路径和。
路径定义：
    1. 同一个节点在路径中最多出现一次；
    2. 路径至少包含一个节点，可以不经过根节点；
```
> [二叉树中的最大路径和_牛客题霸_牛客网](https://www.nowcoder.com/practice/da785ea0f64b442488c125b441a4ba4a)

<!-- 
<details><summary><b>详细描述</b></summary>

```txt
```
-->

</details>

<!-- <div align="center"><img src="../_assets/xxx.png" height="300" /></div> -->

<summary><b>思路：DFS</b></summary>

- 定义函数 `maxGain(node)` 表示以 `node` 为**起点**的最大路径；显然 maxGain 可以通过递归计算（详见代码）；
- 则**经过** `node` 的最大路径和，可以表示为 `node.val + maxGain(node.left), maxGain(node.right)`；因此可以在计算 `maxGain(root)` 的过程中，记录经过每个节点的最大路径和，进而得到全局最大路径。

<details><summary><b>Python</b></summary>

```python
# class TreeNode:
#     def __init__(self, x):
#         self.val = x
#         self.left = None
#         self.right = None
#
# 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可
#
# 
# @param root TreeNode类 
# @return int整型
#
class Solution:
    def maxPathSum(self, root: TreeNode) -> int:
        # write code here

        self.ret = float('-inf')

        def maxGain(node):
            if not node: return 0

            # 如果子路径的 maxGain 为负数，那么对 node 来说 maxGain 就是自己本身；
            max_left = max(0, maxGain(node.left))
            max_right = max(0, maxGain(node.right))
            # 记录“经过”node 节点的最大路径
            self.ret = max(self.ret, node.val + max_left + max_right)
            return node.val + max(max_left, max_right)  # 至少要包含自己本身

        maxGain(root)
        return self.ret
```

</details>

---

### `牛客 No.0007 买卖股票的最好时机(一) (简单, 2022-01)`

[![模拟](https://img.shields.io/badge/模拟-lightgray.svg)](基础-模拟、数学、找规律.md)
[![牛客](https://img.shields.io/badge/牛客-lightgray.svg)](题集-牛客.md)

<!--{
    "tags": ["模拟"],
    "来源": "牛客",
    "难度": "简单",
    "编号": "0007",
    "标题": "买卖股票的最好时机(一)",
    "公司": ["字节", "腾讯"]
}-->

<summary><b>问题简述</b></summary>

```txt
给定一支股票的价格序列，返回买卖一次的最大值；
```
> [买卖股票的最好时机(一)_牛客题霸_牛客网](https://www.nowcoder.com/practice/64b4262d4e6d4f6181cd45446a5821ec)

<!-- 
<details><summary><b>详细描述</b></summary>

```txt
```
-->

</details>

<!-- <div align="center"><img src="../_assets/xxx.png" height="300" /></div> -->

<summary><b>思路：动态规划</b></summary>

- 记 `dp[i]` 表示 `prices[:i]` 中的最小值；
- 则 `ret = max(x - dp[i])`；
- 实际可以用一个变量记录当前最小值，节省空间；

<details><summary><b>Python</b></summary>

```python
#
# 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可
#
# 
# @param prices int整型一维数组 
# @return int整型
#
class Solution:
    def maxProfit(self , prices: List[int]) -> int:
        # write code here
        ret = 0
        min_p = prices[0]
        for x in prices[1:]:
            ret = max(ret, x - min_p)
            min_p = min(x, min_p)
        return ret
```

</details>

---

### `牛客 No.0008 二叉树中和为某一值的路径(二) (中等, 2022-01)`

[![二叉树](https://img.shields.io/badge/二叉树-lightgray.svg)](数据结构-二叉树.md)
[![DFS](https://img.shields.io/badge/DFS-lightgray.svg)](算法-深度优先搜索(DFS).md)
[![牛客](https://img.shields.io/badge/牛客-lightgray.svg)](题集-牛客.md)

<!--{
    "tags": ["二叉树", "DFS"],
    "来源": "牛客",
    "难度": "中等",
    "编号": "0008",
    "标题": "二叉树中和为某一值的路径(二)",
    "公司": []
}-->

<summary><b>问题简述</b></summary>

```txt
给定二叉树 root 和目标值 target，返回所有和为 target 的路径。
规定路径必须从根节点开始到叶子节点。
```
> [二叉树中和为某一值的路径(二)_牛客题霸_牛客网](https://www.nowcoder.com/practice/b736e784e3e34731af99065031301bca)

<!-- 
<details><summary><b>详细描述</b></summary>

```txt
```
-->

</details>

<!-- <div align="center"><img src="../_assets/xxx.png" height="300" /></div> -->

<summary><b>思路：DFS</b></summary>

<details><summary><b>Python</b></summary>

```python
# class TreeNode:
#     def __init__(self, x):
#         self.val = x
#         self.left = None
#         self.right = None
#
# 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可
#
# 
# @param root TreeNode类 
# @param target int整型 
# @return int整型二维数组
#
class Solution:
    def FindPath(self , root: TreeNode, target: int) -> List[List[int]]:
        # write code here
        
        ret = []
        tmp = []
        
        def dfs(node, k):
            if not node: return
            
            tmp.append(node.val)
            k -= node.val
            
            if not node.left and not node.right and k == 0:
                ret.append(tmp[:])
            
            dfs(node.left, k)
            dfs(node.right, k)
            k += node.val
            tmp.pop()
        
        dfs(root, target)
        return ret
```

</details>

---

### `牛客 No.0009 二叉树中和为某一值的路径(一) (简单, 2022-01)`

[![二叉树](https://img.shields.io/badge/二叉树-lightgray.svg)](数据结构-二叉树.md)
[![DFS](https://img.shields.io/badge/DFS-lightgray.svg)](算法-深度优先搜索(DFS).md)
[![牛客](https://img.shields.io/badge/牛客-lightgray.svg)](题集-牛客.md)

<!--{
    "tags": ["二叉树", "DFS"],
    "来源": "牛客",
    "难度": "简单",
    "编号": "0009",
    "标题": "二叉树中和为某一值的路径(一)",
    "公司": ["腾讯", "字节", "京东"]
}-->

<summary><b>问题简述</b></summary>

```txt
给定二叉树 root 和目标值 target，判断是否存在路径和等于 target。
规定路径必须从根节点开始到叶子节点。
```
> [二叉树中和为某一值的路径(一)_牛客题霸_牛客网](https://www.nowcoder.com/practice/508378c0823c423baa723ce448cbfd0c)

<!-- 
<details><summary><b>详细描述</b></summary>

```txt
```
-->

</details>

<!-- <div align="center"><img src="../_assets/xxx.png" height="300" /></div> -->

<summary><b>思路：DFS</b></summary>

<details><summary><b>Python</b></summary>

```python
# class TreeNode:
#     def __init__(self, x):
#         self.val = x
#         self.left = None
#         self.right = None
#
# 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可
#
# 
# @param root TreeNode类 
# @param sum int整型 
# @return bool布尔型
#
class Solution:
    def hasPathSum(self , root: TreeNode, sum: int) -> bool:
        # write code here
        
        def dfs(node, k):
            if not node: return False
            
            if k == node.val and not node.left and not node.right:
                return True
            
            return dfs(node.left, k - node.val) or dfs(node.right, k - node.val)
        
        return dfs(root, sum)
```

</details>

---
